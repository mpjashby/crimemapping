---
title: "Dive into R"
output: 
  learnr::tutorial
runtime: shiny_prerendered
---

```{r setup, include=FALSE}
# load packages
library(gradethis)
library(learnr)
library(lubridate)
library(tidyverse)

# set options
knitr::opts_chunk$set(echo = FALSE)
tutorial_options(exercise.checker = gradethis::grade_learnr)
```



## Intoduction to R

In this tutorial we will learn the basic underpinnings of R. We will then
use these skills to analyse spatial data and make crime maps later in the 
course.

R is an advanced programming language that can be used for sophisticated data
analysis, but it can also be used as a basic calculator. To see this, type 
`2 + 2` in the box below and then click 'Run Code' to see the result (the spaces 
in the code `2 + 2` aren't needed, but make it easier to read the code).

```{r exercise1, exercise=TRUE}

```

```{r exercise1-solution}
2 + 2
```

If you're ever unsure what code you should enter into a box in this tutorial,
you can always click on the 'Solution' button to see the correct code to enter.

The `+` symbol in the code `2 + 2` is known as an *operator*, i.e. a symbol or
group of symbols that combines the values on either side in some way. You can
use all the standard operators you would expect on a calculator (`+` for
addition, `-` for subtraction, `*` for multiplication, `/` for division etc) as
well as some operators unique to R, which we will discover later.

We can also manipulate values using *functions* (code that does something to a
piece of data), which range from the very basic to very complicated. The code
to use a function (sometimes called *calling* the function) has two parts: the
function name followed by a pair of parentheses, inside which are zero or more
*arguments* separated by commas. Arguments are a way of providing input that a
function works on, or to fine-tune the way the function works (we will cover 
this in more detail later).

To try a basic function, type `sqrt(2)` in the box below and click 'Run Code' to 
calculate the square root of 2. The `sqrt()` function has only one argument: the
number that we want to find the square root of.

```{r exercise2, exercise=TRUE}

```

```{r exercise2-solution}
sqrt(2)
```

When you click 'Run Code', R prints the output of your code â€“ in this case, just
the number ``r format(sqrt(2), digits = 7)`` (for now, you can ignore the number 
`[1]` in square brackets). This is fine for basic operations, but often we will 
want to store the result of our work for use later.

Instead of clicking 'Run Code', you can use the shortcut `Cmd+Return` (on Mac)
or `Alt+Enter` (on Windows or Linux) to run the line of code that you cursor is
on.



## Vectors

To store information in R we use *objects*. These come in several different 
types, the most basic of which is called a *vector* (sometimes referred to as an 
*atomic vector*, especially in error messages). A vector is a one-dimensional 
sequence of values of the same type. We can create a simple vector by typing 
`1:10`:

```{r exercise3, exercise=TRUE}

```

```{r exercise3-solution}
1:10
```

In this code, the colon operator `:` is used to create a sequence of values from
1 to 10, which you will see if you click 'Run Code'.

We have already encountered a vector, because R stores the result of the 
operation `2 + 2` (and all other single values) as a vector of length 1.

If we want to store our sequence of numbers for later, we can give the sequence
a name that we can use to refer to it by. To do this, we use the assignment
operator `<-` (a less-than sign followed by a dash). Let's give our vector the
name 'one_to_ten' by using the code `one_to_ten <- 1:10`.

```{r exercise4, exercise=TRUE}

```

```{r exercise4-solution}
one_to_ten <- 1:10
```

Continually typing `<-` can be tedious, so in RStudio (but unfortunately not in
this tutorial) we can use the keyboard shortcut `Option+-` (on Mac) or `Alt+-`
(on Windows or Linux) to insert the complete operator.

When you click 'Run Code' in the box above, nothing happens. This is because, 
instead of printing the result of your code as before, R has now stored it in
an object called `one_to_ten`. If you do not tell R to store the result of some
code in an object, R will print the result by default, but will otherwise store
it in an object with the name you specify.

To see the current value of an object, we can simply type the object name on a
line on its own and run that code.

```{r exercise5-setup}
one_to_ten <- 1:10
```

```{r exercise5, exercise=TRUE}

```

```{r exercise5-solution}
one_to_ten
```

When choosing object names, it is important to remember that if you assign a
value (such as `1:10` or `sqrt(2)`) to an object name, R will overwrite any
existing value of that object name. So in this code:

```r
one_to_ten <- 1:10
one_to_ten <- sqrt(2)
one_to_ten
```

The value of `one_to_ten` printed on the final line will be 
``r format(sqrt(2), digits = 7)``, *not* ``r 1:10``. There is also no way to 
undo assignment of a value to an object, so once you have run the code 
`one_to_ten <- sqrt(2)` it is not possible to recover any previous value that
was assigned to the object `one_to_ten`.


### Naming elements in vectors

We can give each element in a vector a name to make it easier to refer to. For
example, we can use a vector to store the ages of different people.

```r
ages <- c(39, 24, 65)
```

This vector stores the data, but it would be very easy to forget which value
corresponds to which person. If we add names to the vector, it becomes much
easier to manage our data.


```{r exercise5a, exercise=TRUE}
ages <- c("Charlie" = 39, "Mohamed" = 24, "Tao" = 65)

ages
```

Whenever we name elements in an object in R, remember the format 
`"name" = "value"`.

If we want to add names to the elements in an existing vector, we can use the
`set_names()` function.

```{r exercise5b, exercise=TRUE}
ages <- c(39, 24, 65)

ages <- set_names(ages, c("Charlie", "Mohamed", "Tao"))

ages
```

Note that the `set_names()` function returns a new vector with the same values
as the old vector and names added. If we want to add the names to the existing
vector, we can do this by storing the result of `set_names()` in the same object
as the original vector using the assignment operators `<-`.


### Doing things with vectors

Once we have stored one or more values in an object, we can use that object as
the input to operators or functions. We will do that in this code, using 
comments (lines of code beginning with `#`) to help explain as we go.

```{r exercise6, exercise=TRUE, exercise.lines=12}
# assign the value 2 to an object called `two`
two <- 2

# use that object as the input to an operator and a function
two * sqrt(two)

# do that again, but assign the result to a new object
two_times_sqrt_two <- two * sqrt(two)

# print the object value, to check it is what we expect
two_times_sqrt_two
```

Why does running this code cause the same result to be printed twice? Two of
our lines of code (lines 2 and 8) store the results as objects and so don't
print any result. The other two lines (lines 5 and 11) do not assign the
result to an object, so the result is printed by default.

As well as manipulating single-length vectors, both operators and functions can
manipulate every value in a vector in the same way. For example:

```{r exercise7, exercise=TRUE, exercise.lines=10}
# assign a sequence of values to an object
one_to_ten <- 1:10

# multiply all the values in that sequence by 3
one_to_ten * 3

# find the square root of each value, then format the result so that it has only
# two decimal places
round(sqrt(one_to_ten), digits = 2)
```

If we run this code, we get the result ``r 1:10 * 3`` (each value in  the 
original sequence multiplied by 3) and ``r format(sqrt(1:10), digits = 3)`` (the 
rounded square root of each value). This is very useful when working with large 
datasets, since we only have to write one line of code to manipulate every item 
in a vector in the same way.

Not every function works in this way, however. Some functions summarise vectors,
rather than operating on each element at a time. The `mean()` function, for
example, returns a single value representing the arithmetic mean of all the 
values in the vector.

```{r exercise8-setup}
one_to_ten <- 1:10
```

```{r exercise8, exercise=TRUE}
mean(one_to_ten)
```

Whenever you're using a function on a vector with length greater than 1, it is 
important to know whether the function will summarise the vector or operate on
each element separately.


### Accessing elements of a vector

If we want to access a specific element in a vector, we can type the name of the
vector followed by the position of the element we are interested in (this is 
called *subsetting* an object). So:

```{r exercise9-setup}
ages <- c("Charlie" = 39, "Mohamed" = 24, "Tao" = 65)
```

```{r exercise9, exercise=TRUE}
# get the first element
ages[1]

# get the first and second elements
ages[1:2]

# get the first and third elements
ages[c(1, 3)]
```

If the elements in a vector have names, we can use the names to access
elements.

```{r exercise10, exercise=TRUE, exercise.setup="exercise9-setup"}
# access a single element
ages["Charlie"]

# access multiple elements we
ages[c("Charlie", "Tao")]
```



### Check your understanding

```{r vectors-quiz}
quiz(
  caption = "",
  
  question(
    "What does the code `x:y` do?",
    answer(
      "Creates a vector containing a sequence of consecutive numbers from `x` to `y`", 
      correct = TRUE,
      message = "The `:` operator is used to create a sequence of numbers"
    ),
    answer(
      "Divides the value `x` by the value `y` to create the ratio of `x` to `y`", 
      message = "The code `x / y` divides `x` by `y`"
    ),
    answer(
      "Multiplies `x` and `y` together",
      message = "The code `x * y` multiplies `x` and `y`"
    ),
    answer(
      "Adds `x` and `y` together",
      message = "The code `x + y` adds `x` and `y` together"
    ),
    allow_retry = TRUE,
    random_answer_order = TRUE
  ),
  
  question(
    "What R code prints the contents of the object called `ages`?",
    answer(
      "`message(ages)`",
      message = "`message()` is used to print a text message, but if a vector longer than one item is used inside `message()` then what is printed will be all the items in the vector stuck together, so `message(ages)` prints '392465'"
    ),
    answer(
      "`ages` (i.e. just the name of the object)", 
      correct = TRUE,
      message = "To see the contents of an object in R, just type its name"
    ),
    answer(
      "`summary(ages)`",
      message = "`summary()` is used to print a summary of an object, but if the object is numeric then it will print several summary statistics such as the mean value, maximum value etc"
    ),
    answer(
      "`peak_inside(ages)`",
      message = "There is no function called `peak_inside()`, so this code will result in an error message"
    ),
    allow_retry = TRUE,
    random_answer_order = TRUE
  ),
  
  question(
    "If we create an object using the code `ob <- 3` and then on the next line run `sqrt(ob)`, what value does the object `ob` now have?",
    answer(
      "`3`", 
      correct = TRUE,
      message = "`ob` still has the value `3` because we did not assign the result of `sqrt(ob)` to the object `ob`"
    ),
    answer(
      str_glue("`{round(sqrt(3), digits = 3)}`"), 
      message = str_glue("`ob` doesn't have the value {round(sqrt(3), digits = 3)} because we did not store the result of the code `sqrt(3)` in this object (or any other) so the result would have been printed directly on the screen")
    ),
    answer(
      str_glue("`3, {round(sqrt(3), digits = 3)}`"),
      message = str_glue("`ob` doesn't have the value {round(sqrt(3), digits = 3)} because we did not store the result of the code `sqrt(3)` in this object (or any other) so the result would have been printed directly on the screen")
    ),
    answer(
      "`NA`",
      message = "`ob` still has the value 3 because we did not store the result of the code `sqrt(3)` in this object (or any other) so the result would have been printed directly on the screen"
    ),
    allow_retry = TRUE,
    random_answer_order = TRUE
  )
  
  # question(
  #   'If we create a vector using the code `ages <- c("Charlie" = 39, "Mohamed" = 24, "Tao" = 65)`, how can we get the age for Mohamed?',
  #   answer(
  #     "`ages[2]`",
  #     correct = TRUE,
  #     message = 'We could also use `ages["Mohamed"]`'
  #   ),
  #   answer(
  #     '`ages["2"]`',
  #     message = '`ages[2]` would work, but `ages["2"]` (note the quote marks) looks for an element in `ages` with the *name* "2", rather than the second element'
  #   ),
  #   answer(
  #     "`ages$Mohamed`",
  #     message = "The dollar symbol can be used to extract elements from other types of object in R, but not from vectors"
  #   ),
  #   answer(
  #     '`ages("Mohamed")`',
  #     message = "Parentheses are used in R function names, not to access elements in vectors"
  #   ),
  #   allow_retry = TRUE,
  #   random_answer_order = TRUE
  # )
  
)
```

How would you extract Mohamed's age from the vector `ages`?

```{r exercise11, exercise=TRUE, exercise.setup="exercise9-setup"}

```

```{r exercise11-solution}
# either
ages[2]

# or
ages["Mohamed"]
```


### Further reading

Medina, J., and Solymosi, R. 2020. *Introductory R for Criminologists*. [Week 1: Introduction to R](https://rawgit.com/jjmedinaariza/LAWS70821/master/Week_1_Introduction.html).

Wickham, H., and Grolemund, G. 2020. *R for Data Science*. Sebastopol, CA: O'Reilly. [Chapter 20: Vectors](https://r4ds.had.co.nz/vectors.html).



## Types of data

So far, all the values we have used in our code have been numbers. We have
actually used two types of number: whole numbers (referred to in R as 
*integers*) and decimal numbers (referred to in R as *doubles*). Integers and
doubles are two of the four data types we need to know about in R. The two
others are *character* and *logical* vectors.

Character vectors contain text. We could, for example, keep a vector of the 
given names of participants in a study. We use the combine function `c()` to
create a vector, with each element separated by a comma:

```r
given_names <- c("Charlie", "Mohamed", "Tao")
```

Now use the `typeof()` function to check that `given_names` is a character
vector, as expected (click the 'Solution' button for help if you need it).

```{r exercise12-setup}
given_names <- c("Charlie", "Mohamed", "Tao")
```

```{r exercise12, exercise=TRUE}

```

```{r exercise12-solution}
typeof(given_names)
```

Logical vectors contain only values `TRUE` or `FALSE` (written in uppercase). It
is possible to abbreviate `TRUE` to `T` and `FALSE` to `F` in many contexts in
R code, but *do not do this* because it can have expected results.

A vector can only contain elements of exactly one type. If you try to combine 
elements of different types, R will change some of the elements so that all
elements are of the same type. Run this code to see some examples.

```{r exercise13, exercise=TRUE, exercise.lines=10}
# if you attempt to combine logical and numeric elements in a vector, R will 
# create a double-type vector and convert TRUE values to be 1 and FALSE values 
# to be 0
c(3, TRUE)

# if you attempt to combine logical and character elements, or numeric and 
# character elements, R will create a character vector and convert the numeric
# values to character strings containing numbers
c(4:6, FALSE, "banana")
```

Knowing what type of vector you are using is important because many functions in
R can only work with particular types of vectors. For example, if you run this 
code:

```{r exercise14-setup}
given_names <- c("Charlie", "Mohamed", "Tao")
```

```{r exercise14, exercise=TRUE, exercise.lines=6}
# if we try to find the mean of a numeric vector, it works
mean(c(1, 2, 3))

# but if we try to find the mean of a character vector, we get a warning
mean(given_names)
```

In the second case, the `mean()` function returns the value `NA` (which is used
as a place-holder for missing values) and a warning message. A function 
returning `NA` is often a sign that your code is not working as you intended.


### Check your understanding

Type the code needed to create a sequence of numbers from 40 to 50 inclusive:

```{r types-quiz1, exercise=TRUE}

```

```{r types-quiz1-solution}
40:50
```

```{r types-quiz2}
question(
  "What will be the result of the code `typeof(c(1:3, TRUE, NA))`?",
  answer(
    "integer", 
    correct = TRUE,
    message = "When combining values of different types, R ignores `NA` values, so the combination in this case is one of the numeric vector `1:3` and the logical vector `TRUE`, which results in the numeric vector `1, 2, 3, 1`"
  ),
  answer(
    "character", 
    message = "Trying to combine a character item with any other type of item (numberic, logical, etc) creates a character vector, but combining numeric and logical items does not"
  ),
  answer(
    "logical", 
    message = "Whenever logical items are combined with any other type of data, the logical items will be converted to another type, so this vector cannot be a logical vector"
  ),
  answer(
    "NA", 
    message = "R ignores NA values when determining what type of data is in a vector, so you can ignore the NA item when working out what type a vector will be"
  ),
  allow_retry = TRUE,
  random_answer_order = TRUE
)
```


### Further reading

Medina, J., and Solymosi, R. 2020. *Introductory R for Criminologists*. [Week 1: Introduction to R](https://rawgit.com/jjmedinaariza/LAWS70821/master/Week_1_Introduction.html).

Wickham, H., and Grolemund, G. 2020. *R for Data Science*. Sebastopol, CA: O'Reilly. [Chapter 20: Vectors](https://r4ds.had.co.nz/vectors.html).



## Lists

Lists are a type of R object that are much more flexible than vectors. Lists can
become very complicated, but we only need to know a few things about them for
now.

Unlike vectors, lists can contain elements of different types:

```{r exercise15, exercise=TRUE}
# if you attempt to combine logical and numeric elements in a *vector*, R will 
# create a double-type vector and convert TRUE values to be 1 and FALSE values 
# to be 0
c(3, TRUE)

# if you attempt to combine logical and numeric elements in a *list*, the
# elements will retain their original types
list(3, TRUE)
```

Each element in a list can itself contain multiple elements:

```{r exercise16, exercise=TRUE}
# when we create a vector using the c() function, the elements are all combined
# together into a single sequence of values
c(4:6, FALSE, fruit = "banana")

# when we create a list using the list() function, each element (however many
# values it contains) stays separate
list(4:6, FALSE, fruit = "banana")
```

This is one way in which lists are more flexible than vectors, but (as often in
computing) adding greater flexibility creates more complexity. One way you can
see this is in the way that lists are printed, which is more complicated than 
the way in which vectors are printed. Every element in a list is printed on a
separate line.


### Accessing elements in a list

Accessing elements in a list is similar to accessing elements in a vector:

```{r exercise17, exercise=TRUE}
# create a list and store it in the object a_list
a_list <- list(4:6, FALSE, fruit = "banana")

# access the second element in the list
a_list[2]

# print a line to separate the output above from the output below
message("â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€")

# access the second and third elements
a_list[c(2, 3)]
```

We can also access elements of vectors or lists that are themselves inside 
lists, using more than one pair of square brackets. For example, we can access
the second element of the numeric vector that is itself the first element of the
list:

```{r exercise18-setup}
# create a list and store it in the object a_list
a_list <- list(4:6, FALSE, fruit = "banana")
```

```{r exercise18, exercise=TRUE}
a_list[[1]][2]
```

If an item in a list is named, we can also extract it by name:

```{r exercise18a, exercise=TRUE, exercise.setup="exercise18-setup"}
# either
a_list[["fruit"]]

# or
a_list$fruit
```

The use of a combination of multiple single and double (`[[]]`) pairs of square
brackets can be difficult to read, so it is often easier to use the `pluck()`
function to pluck out values from inside lists. So to get the second element in
the vector that is the first element in `a_list`:

```{r exercise19-setup}
# create a list and store it in the object a_list
a_list <- list(4:6, FALSE, "banana")
```

```{r exercise19, exercise=TRUE}
pluck(a_list, 1, 2)
```

`pluck()` also works with vectors: `pluck(one_to_ten, 7)` returns the number 
`7`.

The ability to extract list elements using either square brackets or the 
`pluck()` function is an example of how it is often possible to do the same
thing in R in several different ways.

The ability of lists to contain elements of different types and lengths means
they are very useful for storing different types of data. But one common type of
data is better stored in the final type of object we need to learn about: the
data frame.


### Check you understanding

If we create a list using the R code

```r
some_list <- list(
  4:6, 
  days = c("Mon", "Tue", "Wed"), 
  val = list("Mon" = TRUE, "Tue" = FALSE, "Wed" = NA)
)
```

Type the code that extracts the element 'Tue'

```{r list-quiz-setup}
some_list <- list(
  4:6, 
  days = c("Mon", "Tue", "Wed"), 
  val = list("Mon" = TRUE, "Tue" = FALSE, "Wed" = NA)
)
```

```{r list-quiz1, exercise=TRUE}

```

```{r list-quiz1-solution}
# any one of
some_list[["days"]][2]
some_list[[2]][2]
some_list$days[2]
pluck(some_list, "days", 2)
pluck(some_list, 2, 2)
```

Now type the code that extracts the list with the name 'val'

```{r list-quiz2, exercise=TRUE, exercise.setup="list-quiz-setup"}

```

```{r list-quiz2-solution}
# any one of
some_list[[3]]
some_list[["val"]]
some_list$val
pluck(some_list, 3)
pluck(some_list, "val")
```

### Further reading

Medina, J., and Solymosi, R. 2020. *Introductory R for Criminologists*. [Week 1: Introduction to R](https://rawgit.com/jjmedinaariza/LAWS70821/master/Week_1_Introduction.html).

Wickham, H., and Grolemund, G. 2020. *R for Data Science*. Sebastopol, CA: O'Reilly. [Chapter 20: Vectors](https://r4ds.had.co.nz/vectors.html).



## Data frames

```{r crime-data}
# create some basic crime data
crime_data <- tribble(
  ~type, ~date, ~address,
  "homicide", as_date(now() - years(1) + days(10)), "274 Main St",
  "non-residential burglary", as_date(now() - months(5) + days(20)), "541 Station Rd",
  "personal robbery", as_date(now() - days(8)), "10 North Av"
) %>% 
  mutate(date = strftime(date, "%d %b %Y"))
```

Data used in mapping and other types of analysis often take the format of 
tables: rectangular data containing multiple columns where every column has the 
same number of rows. For example, crime data might have columns for the type of
crime, date and address at which the crime occurred.

```{r tabular-data}
tribble(
  ~type, ~date, ~address,
  "homicide", as_date(now() - years(1) + days(10)), "274 Main St",
  "non-residential burglary", as_date(now() - months(5) + days(20)), "541 Station Rd",
  "personal robbery", as_date(now() - days(8)), "10 North Av"
) %>% 
  mutate(date = strftime(date, "%d %b %Y")) %>% 
  knitr::kable(caption = "Crime data in rectangular format")
```

You could store each column as a separate vector (because all the data in each
column is of a single type), or store each row as a separate list. But either of
these options would make the data inconvenient to work with, as well as 
potentially creating a large number of objects that would be hard to keep track
of if your dataset were larger.

Instead, R can store rectangular data as a *data frame*. The format of data 
frames in R has not substantially changed in 20 years, whereas there have been
lots of advances in data science in that time. Because of this, instead of using
data frames directly we will use a modern equivalent called (slightly strangely)
a *tibble*. Tibbles behave just like data frames almost all of the time (so much
so that people working with tibbles often call them data frames) except for a
few occasions where they behave in a more-convenient way.

One example of tibbles being more convenient to use than data frames is what 
happens if you type the name of a tibble or data frame into the R console to see 
the data contained in it. If you do this with a data frame, R will
attempt to print every row of data, even if this floods the console screen with
data. If you type the name of a tibble into the console to view its contents, R
will only print up to 10 rows, and will only print as many columns as fit on the
screen. There are [lots of other small benefits to using tibbles](https://tibble.tidyverse.org) 
instead of data frames, which is why we will use tibbles throughout these 
tutorials.

Under the hood, tibbles (and data frames) are actually a list of vectors, which
means we can access elements inside data frames in the same ways we access
values within lists and vectors. For example, if the tibble shown above is 
named `crime_data`, we can extract the whole second column (the offence dates)
using either square brackets, the dollar-sign operator or `pluck()`:

```{r exercise21, exercise=TRUE, exercise.setup="crime-data"}
# using square brackets
crime_data[[2]]
crime_data[["date"]]

# using the dollar-sign operator
crime_data$date

# using pluck()
pluck(crime_data, 2)
```

I prefer to use `pluck()` in most circumstances, but you may prefer the other
options.

We can also get the value from the second row of the third column 
(`541 Station Rd`):

```{r exercise22, exercise=TRUE, exercise.setup="crime-data"}
# using square brackets
crime_data[[3]][2]
crime_data[["address"]][2]

# using the dollar-sign operator
crime_data$address[2]

# using pluck()
pluck(crime_data, 3, 2)
```

We will learn how to do lots of other things with tibbles in future tutorials,
but that is about all we need to know for now.



## Packages

```{r count-cran-packages}
package_count <- available.packages(repos = "https://cran.rstudio.com/") %>% 
  nrow() %>% 
  scales::comma(accuracy = 100)
```

R contains thousands of different functions that do different things. A few 
functions are contained in the default installation of R that you have already
installed (this is sometimes referred to as *base R*). But most functions are
contained in *packages*, which are extensions to base R. Most packages focus
on a particular type of data analysis, so that there are packages devoted to
time-series analysis, testing whether events are clustered in particular places,
network analysis and thousands of other tasks. Packages are often developed by
experts in the field, and are typically updated to introduce new features.

To use a package in R, we must do two things:

  * *install* the package, which we have to do just once on each computer we
    want to use, then
  * *load* the package, which we have to do each time we restart R (which
    happens when we open RStudio or switch between projects).
    
the `install.packages()` function downloads and installs packages from the 
[Comprehensive R Archive Network](https://cran.r-project.org/) (universally 
known as CRAN), which at the time of writing contains about `r package_count`
different packages. Some packages that are still in the early stages of 
development are not available on CRAN, but all the packages we will use are.

The `crimedata` package contains functions that allow us to download large
amounts of crime data for large cities in the United States. To install this
package, we use `install.packages()`.

```r
install.packages("crimedata")
```

We only have to do this once for each computer that we will use to run R,
although we would have to do it again if we updated to a new version of R.

Now the package is installed on our computer, we have to load it so that we can
use it in our code. We load packages using the `library()` function, which 
should probably have been called `load_package()` but isn't.

```r
library("crimedata")
```

Some of the functions we have already used have been from packages. For example,
the `pluck()` function comes from the `purrr` package. There are some packages
that are so useful that we will load them in almost all the code we write.
Fortunately, packages can themselves load other packages, and all the main
packages we need are themselves loaded by the `tidyverse` package. That is why
you will often see `library("tidyverse")` at the top of R code in subsequent
tutorials.


### Clashing function names

Because there are so many R packages, you will sometimes find that more two or more packages contain 
functions that have the same name but do different things. If there are two functions both called (for example) `process()` from 
different packages, there is no way for R to know which function you intended to
call. To deal with this problem, if multiple packages contain functions with the
same name, R will only use the function from the package that you loaded *last*.

To warn out about this, if you load a package that contains a function with the
same name as a function that has already been loaded by another package, R will
warn you that the already-loaded function has been 'masked' by the new one. For
example, if you load the package `dplyr` and then the package `Hmisc` (both of
which contain a function called `summarize()`):

```r
library("dplyr")
library("Hmisc")
```

you will get this warning:

```
Attaching package: â€˜Hmiscâ€™

The following objects are masked from â€˜package:dplyrâ€™:

    src, summarize

The following objects are masked from â€˜package:baseâ€™:

    format.pval, units
```

There are two ways to deal with this. If you know in advance which function you
want, you can just make sure that you load the corresponding package last of all
the packages that you load. In most of the code in this course, the functions we
want will be from the tidyverse packages, so we usually run 
`library("tidyverse")` after loading all the other packages we need.

If you don't know at the start of your analysis which function you need, you can
explicitly tell R which function to use by adding the package name before the
function name, separated by two colons `::` without spaces:

```r
dplyr::summarize()
```

In fact, if you specify the function you want in this way, there is no need to
load the package using `library()` first.



## Code style

You can make your R code much clearer by following a few conventions. This is
especially important in avoiding errors in your code, and makes it easier to 
find errors when you do make them (everyone makes errors when writing code).


### Naming objects

R objects can have any name you like, as long as the name starts with a letter
and contains only letters, numbers, dots (`.`) and underscores (`_`). That said,
you will find coding easier if you follow a few conventions.

  * Use only lower-case letters in the names of objects, which avoids you having
    to remember whether a particular letter was upper- or lower-case.
  * Use *snake case* (`object_name`, with words separated by underscores) for 
    object names rather than camel case (`objectName`) or kebab case 
    (`object-name`), and don't use dots in object names.
  * Don't give objects the same names as R functions, because re-using function
    names makes reading your code more difficult.


### Spacing

Spacing out code makes it much easier to read, but (just as in any language)
code is easiest to read if spaces are used where people expect them to be by
convention.

Put a space after a comma (just as in English):

```r
# Good
x[, 1]

# Bad
x[,1]
x[ ,1]
x[ , 1]
```

Don't put spaces inside parentheses, or between the names of functions and the
parentheses:

```r
# Good
mean(x, na.rm = TRUE)

# Bad
mean (x, na.rm = TRUE)
mean( x, na.rm = TRUE )
```

Do put spaces around most operators (`==`, `+`, `-`, `<-`, etc):

```r
# Good
height <- (feet * 12) + inches
mean(x, na.rm = TRUE)

# Bad
height<-feet*12+inches
mean(x, na.rm=TRUE)
```

Although there are some operators that shouldn't have spaces around them: `$`, 
`@`, `[`, `[[`, `^`, `:` and `?`.



### Functions

In general, you should keep lines of code to a maximum of 80 characters long,
since they can easily fit on most screens and are easy to read.

When calling a function, put all of the parameters on a single line if they will 
fit into 80 characters or less:

```r
do_something_simple("something", with = "only", short, "arguments")
```

But if the function call is longer than 80 characters, use one line each for the 
function name, each argument, and the closing `)`, with the arguments indented
by two spaces. This makes the code much easier to read.

```r
# Good
do_something_very_complicated(
  something = "that",
  requires = many,
  arguments = "some of which may be long"
)

# Bad
do_something_very_complicated("that", requires, many, arguments,
                              "some of which may be long"
                              )
```

When combining multiple functions using the pipe operator (`%>%`, which we will
learn about later), put each function on a single line, with all but the first
line indented by two spaces:

```r
a_function() %>% 
  another_function() %>% 
  and_a_third_function()
```

Once you learn about other types of R code you will need to know how best to 
style it, but we will learn about those when we need to.

You can get help on styling your R code using the [`styler`](https://styler.r-lib.org) 
package, which can automatically format your code for you. RStudio will also try
to help with code style like indenting lines.


### Acknowledgements

Some material in this section is based on the [The tidyverse style guide](https://style.tidyverse.org/)
by Hadley Wickham, which is licensed under a [Creative Commons Attribution-ShareAlike licence](https://github.com/tidyverse/style/blob/master/LICENSE.md).



## Conclusion

In this tutorial we have learned the basics of the R language. This will help 
you understand the R code we use later to make maps and analyse spatial data. 
There is a lot more to learn about R, but you will be able to build on this
foundation as you progress through the rest of the course.

In the next tutorial, we will learn how to wrangle data in R. To load this
tutorial, close this window to return to the main RStudio window, then type

```r
learnr::run_tutorial("04_data_wrangling", package = "crimemapping")
```

in the R Console.
